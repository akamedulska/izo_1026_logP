{
  "hash": "04703fe8b79914d260d996cdd9609930",
  "result": {
    "markdown": "# Initial model\n\nAt the beginning we used a model with partial pooling and a common distribution for analyte-specific parameters. The second level of model is expressed as follows: \\begin{align*}\n R_i \\sim \\text{MST}(\\nu,\\theta_R + \\beta \\cdot log P_i, \\Omega) ,\n\\end{align*} where $R_i=(\\log k_{w_i}, \\log k_{a_i}, \\log S_{2_i})$ is a vector of analyte-specific chromatographic parameters, MST is a multivariate Student's $t$-distribution, $\\theta_R$ is a vector of the expected values of $R_i$ for the analyte with $\\log P_i = 0$, and $\\beta$ is a vector of slopes between $\\log P_i$ and $R_i$. In turn, $\\Omega$ is the covariance matrix for the random effects related to the residual and unexplained between-analyte variability. The MST distribution with $\\nu$ was used to ensure flexibility and robustness for analytes with unusually high or low values of $R_i$.\n\n## Priors\n\nIn this work were used weakly uninformative priors as described in our previous work [@Kubik2018]: \\begin{align*}\n\\nu \\sim Gamma(2,0.1),\\\\\n\\theta_{\\log k_{w}} \\sim N(2,5),  \\quad \\theta_{\\log k_{a}} \\sim N(0,5),\\\\\n\\theta_{\\log S_{2}},  \\sim N(\\log 2,0.5), \\\\\n\\beta_{\\log k_{w}} \\sim N(1,0.5), \\quad\n\\beta_{\\log k_{a}} \\sim N(1,0.5), \\\\\n\\text{logPmissing} \\sim N(2.56,1.92), \\\\\n\\omega \\sim N(0,5),\\\\\n\\begin{bmatrix}\n 1 & \\rho_{1,2} & \\rho_{1,3} \\\\\n \\rho_{2,1} & 1 & \\rho_{2,3} \\\\\n \\rho_{3,1} & \\rho_{3,2} & 1 \n \\end{bmatrix} \\sim LKJ(1), \\\\\n\\sigma \\sim N(0,1),\\\\\n\\eta \\sim MST(\\nu,\\theta_{\\eta},\\Omega).\n\\end{align*}\n\n## Analysis\n\nAt the beginning, a model was constructed and implemented in the Stan program.\n\n\n::: {.cell output.var='initial_model'}\n\n```{.stan .cell-code}\nfunctions{\n  real hplcmodel(real fi, real logkw, real logka, real logS2A){\n    \n    real logk;\t\t\t\t\t\t\t\t\t\t\t\t// retention factor\n    real S1;\t\t\t\t\t\t\t\t\t\t\t\t// slope coefficient\n    \n    S1 = (logkw - logka)*(1+exp(logS2A));\n    logk\t\t\t\t\t= logkw - S1 * fi / (1 + exp(logS2A) * fi);\n    \n    return logk;\n  }\n}\ndata{\n  int nAnalytes;\t\t\t\t\t\t\t\t\t\t\t// number of analytes\n  int nObs;\t\t\t\t\t\t\t\t\t\t\t\t// number of observations\n  int analyte[nObs];\t\t\t\t\t\t\t\t\t\t// analytes indexes\n  vector[nObs] logkObs;\t\t\t\t\t\t\t\t\t// observed retention factors\n  vector[nObs] fi;\t\t\t\t\t\t\t\t\t\t// organic modifier content in the mobile phase\n  real logP[nAnalytes];      \n  int idxmissing[nAnalytes];\n  int nfiplot;\t\t\t\t\t\t\t\t\t\t\t// number of fi for plotting\n  vector[nfiplot] fiplot;\t\t\t\t\t\t\t\t\t// organic modifier content in the mobile phase\n  \n  int<lower = 0, upper = 1> run_estimation; // 0 for prior predictive, 1 for estimation\n}\n\ntransformed data{\n  vector[3] etaHat;\n  etaHat\t\t\t\t\t= rep_vector(0.0,3);\n}\n\nparameters{\n  real logkaHat;\t\t\t\t\t\t\t\t\t\t   // retention factor in acetonitrile for  analyte with MLOGP 0\n  real logS2AHat;\t\t\t\t\t\t\t\t           // mean curvature coefficient for acetonitrile in population\n  real<lower = 0> sigmaadd;\t\t\t\t\t\t\t   // standard deviation for residuals\n  corr_matrix[3] rho;\t\t\t\t\t\t\t\t\t   // correlation matrix\n  vector<lower = 0>[3] omega;\t\t\t\t\t\t\t   // diagonal elements of variance-covariance matrix\n  real logkwHat;\t\t\t\t\t\t\t\t\t\t   // mean value of logkw in population\n  vector[3] eta[nAnalytes];\t\t\t\t\t\t\t   // inter-individual variability\n  real beta_logkw;\t\t\t\t\t\t\t\t\t   // coefficient value for molecular descriptor\n  real beta_logka;\n  real nu;\t\t\t// normality constant\n  real logPmissing[nAnalytes];\n}\n\ntransformed parameters{\n  cov_matrix[3] Omega;\t\t\t\t\t\t\t\t\t// variance-covariance matrix\n  real logka[nAnalytes];\t\t\t\t\t\t\t\t\t// slope coefficient for acetonitrile\n  real logS2A[nAnalytes];\t\t\t\t\t\t\t\t\t// curvature coefficient for acetonitrile\n  real logkw[nAnalytes];\t\t\t\t\t\t\t\t\t// retention factor in neat water\n  vector[nObs] logkHat;\t\t\t\t\t\t\t\t\t// mean value of logk in population\n  \n  Omega = quad_form_diag(rho, omega);\t// diag_matrix(omega) * rho * diag_matrix(omega)\n  \n  for(j in 1:nAnalytes){\n    logka[j]  = eta[j, 1] + logkaHat + beta_logka * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]);\n    logS2A[j] = eta[j, 2] + logS2AHat;\n    logkw[j]  = eta[j, 3] + logkwHat + beta_logkw * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]);\n  }\n  \n  for(i in 1:nObs){\n    logkHat[i] = hplcmodel(fi[i], logkw[analyte[i]], logka[analyte[i]], logS2A[analyte[i]]);\n  }\n}\n\nmodel{\n  logkwHat\t\t\t\t~ normal(2, 5);\n  logkaHat\t\t\t    ~ normal(0, 5);\n  logS2AHat\t\t\t\t~ normal(log(2), 0.5);\n    beta_logkw         \t    ~ normal(1,0.5);\n    beta_logka         \t    ~ normal(1,0.5);\n  logPmissing ~ normal(2.56,1.92);\n  omega\t\t\t\t\t~ normal(0,5);\n  nu                      ~ gamma(2,0.1);\n  rho\t\t\t\t\t\t~ lkj_corr(1);\n  sigmaadd\t\t\t\t~ normal(0,1);\n  eta\t\t\t\t\t\t~ multi_student_t(nu,etaHat, Omega);\t// inter-individual variability\n\n  if(run_estimation==1){\n  logkObs\t\t\t\t\t~ normal(logkHat, sigmaadd);\t// observations\n}\n\n}\n\ngenerated quantities{\n  \n  vector[3] etaPred[nAnalytes];\t\t\t\t\t\t\t// etas\n  real logkaPred[nAnalytes];\t\t\t\t\t\t\t\t// etention factor in acetonitrile\n  real logS2APred[nAnalytes];\t\t\t\t\t\t\t\t// curvature coefficient for acetonitrile\n  real logkwPred[nAnalytes];\t\t\t\t\t\t\t\t// retention factor in neat water\n  vector[nObs] logkHatPred;\t\t\t\t\t\t    \t// predicted logk\t\n  real logkCond[nObs];\n  real logkPred[nObs];\n  real log_lik[nObs];\n  real log_likPred[nObs];\n  matrix[nAnalytes,nfiplot] logkHatPlotACond;\n  matrix[nAnalytes,nfiplot] logkPlotACond;\n  matrix[nAnalytes,nfiplot] logkHatPlotAPred;\n  matrix[nAnalytes,nfiplot] logkPlotAPred;\n  \n  for(j in 1:nAnalytes){\n    etaPred[j] = multi_student_t_rng(nu,etaHat, Omega);\t// inter-individual variability\n    logkaPred[j] = etaPred[j, 1] + logkaHat + beta_logka * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]);\n    logS2APred[j]\t= etaPred[j, 2] + logS2AHat;\n    logkwPred[j]\t= etaPred[j, 3] + logkwHat + beta_logkw * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]);\n  }\n  \n  for(i in 1:nObs){\n    logkHatPred[i]\t= hplcmodel(fi[i], logkwPred[analyte[i]], logkaPred[analyte[i]], logS2APred[analyte[i]]);\n    logkCond[i]\t\t= normal_rng(logkHat[i], sigmaadd);\n    logkPred[i]\t\t= normal_rng(logkHatPred[i], sigmaadd);\n    log_lik[i]\t\t= normal_lpdf(logkObs[i] | logkHat[i], sigmaadd);\n    log_likPred[i]\t= normal_lpdf(logkObs[i] | logkHatPred[i], sigmaadd);\n  }\n  \n  for(j in 1:nAnalytes){\n    for(z in 1:nfiplot){\n      logkHatPlotACond[j,z]\t= hplcmodel(fiplot[z], logkw[j], logka[j], logS2A[j]);\n      logkPlotACond[j,z]\t\t= normal_rng(logkHatPlotACond[j,z], sigmaadd);\n      \n      logkHatPlotAPred[j,z]\t= hplcmodel(fiplot[z], logkwPred[j], logkaPred[j], logS2APred[j]);\n      logkPlotAPred[j,z]\t\t= normal_rng(logkHatPlotAPred[j,z], sigmaadd);\n      \n    }\n  }\n  \n}\n```\n:::\n\n\nThen, the data was added to it and the initial values of the model parameters were determined. In the end, the model was fitted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# indicating missing value of log P\nidxmissing <- rep(0,1026)\nidxmiss <- which(is.nan(DS$logP_ACD[!duplicated(DS$ID)]))\nidxmissing[idxmiss] <- 1\n\nDS$logP_ACD[which(DS$ID %in% idxmiss)] <- 0\n\n# data to model\ndatastruct_prior = with(DS,\n                    list(logP=DS$logP_ACD[!duplicated(DS$ID)],\n                       idxmissing=idxmissing,\n                       nAnalytes=nAnalytes,\n                       nObs=nObs,\n                       analyte=DS$ID,\n                       logkObs=DS$logk, \n                       fi=DS$concentration,\n                       nfiplot=length(fi),\n                       fiplot=fi,\n                       run_estimation=0))\n\ndatastruct = with(DS,\n                  list(logP=DS$logP_ACD[!duplicated(DS$ID)],\n                       idxmissing=idxmissing,\n                       nAnalytes=nAnalytes,\n                       nObs=nObs,\n                       analyte=DS$ID,\n                       logkObs=DS$logk, \n                       fi=DS$concentration,\n                       nfiplot=length(fi),\n                       fiplot=fi,\n                       run_estimation=1))\n\n# declaring initial values for each variable in chains\ninit <- function(){\n  list(logkwHat  = mean(inital_param_A[,2]+rnorm(nAnalytes,0,0.5)),\n       logkaHat  = rnorm(1,0,0.5),\n       logS2AHat = log(2)+rnorm(1,0,0.5),\n       \n       beta_logka = 0.4+rnorm(1,0,0.1),\n       beta_logkw = 0.8+rnorm(1,0,0.1),\n       \n       eta= matrix(rnorm(nAnalytes*3,0,0.5),nAnalytes,3),\n       \n       rho = diag(1,3,3),\n       \n       nu = max(1, 10+rnorm(1,0,2)),\n       \n       omega= c(3,3,3)*exp(rnorm(3,0,0.2)),\n       sigmaadd = 0.2*exp(rnorm(1,0,0.2))\n  )\n}\n\n# specifying parameters to analysis \nparametersToPlot <- c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"beta_logka\",\"beta_logkw\",\"eta\",\"rho\",\"nu\",\"omega\",\"sigmaadd\")\notherRVs <- c(\"logkCond\",\"logkPred\",\"logkPlotACond\",\"logkPlotAPred\",\"log_lik\",\"log_likPred\",\n              \"eta\",\"etaPred\")\n\nparameters <- c(parametersToPlot, otherRVs)\nparametersToPlot <- c(\"lp__\", parametersToPlot)\n\n# fitting model\nfit_prior <- stan(file=\"HPLCizomodel44.stan\",\n            data=datastruct_prior,\n            pars=parameters,\n            iter=2000,\n            warmup=1000,\n            init=init,\n            chains=4,thin=1,control = list(adapt_delta = 0.9,max_treedepth=15))\n\nfit <- stan(file=\"ACN000.stan\",\n                   data=datastruct,\n                   pars=parameters,\n                   iter=2000,\n                   warmup=1000,\n                   init=init,\n                   chains=4,thin=1,control = list(max_treedepth=12))\n```\n:::\n\n\nBelow code preapering data to fit the model in supercomputer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages\nlibrary(pracma)\nlibrary(dplyr)\nlibrary(ggplot2)\nrequire(gridExtra)\nlibrary(GGally)\nlibrary(cmdstanr)\nlibrary(rstan)\nlibrary(knitr)\nlibrary(reshape2)\nlibrary(bayesplot)\nlibrary(posterior)\n\n# load data\nDS       <- read.csv(here::here(\"1_data/database_stan_1026.csv\"),header = TRUE, sep = \";\", dec = \".\")\nDS_names <- read.csv(here::here(\"1_data/database_stan_1026_analyte_names.csv\"),header = TRUE, sep = \",\", dec = \".\")\nDS_pKa   <- read.csv(here::here(\"1_data/ACD_pKas.csv\"),header = TRUE, sep = \",\", dec = \".\")\n\nidxmissing <- rep(0,1026)\nidxmiss <- which(is.nan(DS$logP_ACD[!duplicated(DS$ID)]))\nidxmissing[idxmiss] <- 1\nDS$logP_ACD[which(DS$ID %in% idxmiss)] <- 0\n\nlogP=DS$logP_ACD[!duplicated(DS$ID)]\nnAnalytes=length(unique(DS$ID))\nnObs=length(DS$ID)\nanalyte=DS$ID\nlogkObs=DS$logk\nfi=DS$concentration\nfiplot=seq(0,1,0.1)\nnfiplot=length(fiplot)\nrun_estimation=1\n\nstan_rdump(c(\"logP\",\n             \"nAnalytes\", \n             \"nObs\",\n             \"idxmissing\", \n             \"analyte\", \n             \"logkObs\", \n             \"fi\",\n             \"nfiplot\",\n             \"fiplot\",\n             \"run_estimation\"),\n           file=\"2_initial_model/model.data.R\")\n\ninital_param_A <- matrix(NA,nAnalytes,2)\nfor(i in 1:nAnalytes){\n  inital_param_A[i,] = \n    polyfit(DS$concentration[which(DS$ID==i)]/(1+2*DS$concentration[which(DS$ID==i)]),\n            DS$logk[which(DS$ID==i)],1)\n}\n\nfor(i in 1:10){\n  logkwHat  =  mean(inital_param_A[,2]+rnorm(nAnalytes,0,0.5))\n  logkaHat  = rnorm(1,0,0.5)\n  logS2AHat = log(2)+rnorm(1,0,0.5)\n  beta_logka = 0.4+rnorm(1,0,0.1)\n  beta_logkw = 0.8+rnorm(1,0,0.1)\n  eta= matrix(rnorm(nAnalytes*3,0,0.5),nAnalytes,3)\n  rho = diag(1,3,3)\n  nu = max(1, 10+rnorm(1,0,2))\n  omega= c(3,3,3)*exp(rnorm(3,0,0.2))\n  sigmaadd = 0.2*exp(rnorm(1,0,0.2))\n  \n  stan_rdump(c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"beta_logka\",\"beta_logkw\",\"eta\",\n               \"rho\",\"nu\",\"omega\",\"sigmaadd\"),\n             file=paste(\"2_initial_model/model_\", i, \".init.R\", sep=\"\"))\n}\n```\n:::\n\n\n## Summary of model parameters\n\nCode for print summary of parameters from supercomputer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- cmdstanr::as_cmdstan_fit(c('2_initial_model/output_1.csv',\n                                  '2_initial_model/output_2.csv',\n                                  '2_initial_model/output_3.csv',\n                                  '2_initial_model/output_4.csv',\n                                  '2_initial_model/output_5.csv',\n                                  '2_initial_model/output_6.csv',\n                                  '2_initial_model/output_7.csv',\n                                  '2_initial_model/output_8.csv',\n                                  '2_initial_model/output_9.csv',\n                                  '2_initial_model/output_10.csv'))\n\nfit$print(c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"beta_logka\",\"beta_logkw\",\"rho\",\"nu\",\"omega\",\"sigmaadd\"), max_rows = 26)\n```\n:::\n\n\nCode for print summary of parameters from computer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(\"2_initial_model/Fit.Rsave\")\nload(\"2_initial_model/Fit_sample.Rsave\")\n\nprint(fit,pars=c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"beta_logka\",\"beta_logkw\",\"rho\",\"nu\",\"omega\",\"sigmaadd\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInference for Stan model: HPLCizomodel44.\n4 chains, each with iter=2000; warmup=1000; thin=1; \npost-warmup draws per chain=1000, total post-warmup draws=4000.\n\n            mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat\nlogkwHat    1.70    0.01 0.10  1.52  1.63  1.70  1.77  1.89    98 1.05\nlogkaHat   -1.99    0.01 0.06 -2.11 -2.04 -1.99 -1.95 -1.87    91 1.09\nlogS2AHat   1.06    0.00 0.02  1.02  1.04  1.06  1.07  1.09   545 1.01\nbeta_logka  0.25    0.00 0.02  0.21  0.24  0.25  0.26  0.29   124 1.03\nbeta_logkw  0.97    0.00 0.03  0.90  0.94  0.97  0.99  1.03   201 1.02\nrho[1,1]    1.00     NaN 0.00  1.00  1.00  1.00  1.00  1.00   NaN  NaN\nrho[1,2]    0.29    0.00 0.04  0.21  0.26  0.29  0.32  0.36  1572 1.00\nrho[1,3]    0.54    0.00 0.03  0.49  0.52  0.54  0.56  0.59  4342 1.00\nrho[2,1]    0.29    0.00 0.04  0.21  0.26  0.29  0.32  0.36  1572 1.00\nrho[2,2]    1.00    0.00 0.00  1.00  1.00  1.00  1.00  1.00  3956 1.00\nrho[2,3]    0.35    0.00 0.04  0.27  0.32  0.35  0.38  0.42  1662 1.00\nrho[3,1]    0.54    0.00 0.03  0.49  0.52  0.54  0.56  0.59  4342 1.00\nrho[3,2]    0.35    0.00 0.04  0.27  0.32  0.35  0.38  0.42  1662 1.00\nrho[3,3]    1.00    0.00 0.00  1.00  1.00  1.00  1.00  1.00   780 1.00\nnu          5.01    0.03 0.56  4.05  4.62  4.96  5.35  6.25   474 1.01\nomega[1]    0.93    0.00 0.03  0.88  0.91  0.93  0.95  0.99   891 1.01\nomega[2]    0.43    0.00 0.02  0.40  0.42  0.43  0.45  0.47  1436 1.00\nomega[3]    1.43    0.00 0.05  1.33  1.39  1.43  1.46  1.53  1262 1.00\nsigmaadd    0.04    0.00 0.00  0.04  0.04  0.04  0.04  0.04  1429 1.00\n\nSamples were drawn using NUTS(diag_e) at Sun Mar 22 03:24:00 2020.\nFor each parameter, n_eff is a crude measure of effective sample size,\nand Rhat is the potential scale reduction factor on split chains (at \nconvergence, Rhat=1).\n```\n:::\n:::\n\n\n## Goodness of fit\n\nThe graphs below were used to check how well the model fits the set of observations. The one on the left compares individual predictions with actual observations. The one on the right shows population predictions with actual observations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(apply(fit_sample$logkCond,2,mean),DS$logk,cex.lab=1.2,xlim=c(-4,6),ylim=c(-3,3),pch=20,col=\"blue\",ylab=expression(\"Log k\"[Obs]),xlab=expression(\"Log k\"[Pred]))\nlines(seq(-4,6,by=0.1),seq(-4,6,by=0.1),lwd=2)\nplot(apply(fit_sample$logkPred,2,mean),DS$logk,cex.lab=1.2,xlim=c(-4,6),ylim=c(-3,3),pch=20,col=\"blue\",ylab=expression(\"Log k\"[Obs]),xlab=expression(\"Log k\"[Pred]))\nlines(seq(-4,6,by=0.1),seq(-4,6,by=0.1),lwd=2)\n```\n\n::: {.cell-output-display}\n![](initial_model_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n### Analysis of eta's\n\nIntra-analyte residues for analyte-specific parameters were also determined and are shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neta_logka <- apply(drop(fit_sample$eta[,,1]), MARGIN = 2, FUN = mean)\neta_logS2A <- apply(drop(fit_sample$eta[,,2]), MARGIN = 2, FUN = mean)\neta_logkw <- apply(drop(fit_sample$eta[,,3]), MARGIN = 2, FUN = mean)\n\nDS_corr <- as.data.frame(cbind(eta_logka,eta_logS2A,eta_logkw))\n\nlibrary(GGally)\n\nggpairs(DS_corr, \n        columns =  c(\"eta_logkw\",\"eta_logka\",\"eta_logS2A\"),\n        lower=list(continuous='points'), \n        columnLabels = c(\"eta[ logk[w]]\",\"eta[ logk[a]]\",\"eta[ logS[2]]\"),\n        labeller = label_parsed,\n        diag=list(continuous=wrap(\"barDiag\", fill=\"darkblue\"))\n)+ theme_grey(base_size = 15)\n```\n\n::: {.cell-output-display}\n![](initial_model_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nThe plot shows that the distribution of residuals in the case of the $\\log k_a$ parameter is bimodal. It indicates that analytes with a similar log P are grouped into two clusters.\n\n### WAIC\n\nWAIC was also used to evaluate the model. This parameter estimates the effective number of parameters to adjust for overfitting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(loo)\nwaic(extract_log_lik(fit)) # waic(fit_sample$log_lik)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: \n1417 (27.8%) p_waic estimates greater than 0.4. We recommend trying loo instead.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nComputed from 4000 by 5097 log-likelihood matrix\n\n          Estimate    SE\nelpd_waic   7819.9  97.3\np_waic      1961.6  56.0\nwaic      -15639.9 194.6\n\n1417 (27.8%) p_waic estimates greater than 0.4. We recommend trying loo instead. \n```\n:::\n\n```{.r .cell-code}\nloo(extract_log_lik(fit))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Relative effective sample sizes ('r_eff' argument) not specified.\nFor models fit with MCMC, the reported PSIS effective sample sizes and \nMCSE estimates will be over-optimistic.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some Pareto k diagnostic values are too high. See help('pareto-k-diagnostic') for details.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nComputed from 4000 by 5097 log-likelihood matrix\n\n         Estimate    SE\nelpd_loo   7250.4 103.5\np_loo      2531.2  64.1\nlooic    -14500.8 206.9\n------\nMonte Carlo SE of elpd_loo is NA.\n\nPareto k diagnostic values:\n                         Count Pct.    Min. n_eff\n(-Inf, 0.5]   (good)     2491  48.9%   208       \n (0.5, 0.7]   (ok)       1116  21.9%   57        \n   (0.7, 1]   (bad)      1236  24.2%   13        \n   (1, Inf)   (very bad)  254   5.0%   2         \nSee help('pareto-k-diagnostic') for details.\n```\n:::\n:::\n\n\n## Predictions\n\nIndividual predictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggpubr)\nnazwy <- c(\"Caffeine\",\"Chlorpropamide\",\"Doxepin hydrochloride\",\"Perphenazine\",\n  \"Pindolol\",\"Phenylbutazone\",\"Procainamide hydrochloride\",\"Retinoic acid\",\n  \"Sulfaphenazole\",\"Tolbutamide\",\"Ketoprofen\",\"Indomethacin\")\nl_nazwy <- which(DS_names$Analyte[!duplicated(DS_names$ID)] %in% nazwy)\n\nplots <- list()\nfor(i in 1:nAnalytes){\n  l <- apply(drop(fit_sample$logkPlotACond[,i,]), MARGIN = 2, FUN = quantile, probs = c(.025,.5,.975))\n  logk_prct <- as.data.frame(cbind(rep(i,11),fiplot,t(l)))\n  colnames(logk_prct)<-c(\"ID\",\"concentration\",\"low\",\"median\",\"high\")\n  plots[[i]] <- ggplot()+ xlim(0,1) +\n    geom_point(data=subset(DS, ID == i), aes(x = concentration, y = logk), col=\"blue\") +\n    geom_line(data=subset(logk_prct, ID == i), aes(x = fiplot, y = median), col=\"blue\") +\n    geom_ribbon(data=subset(logk_prct, ID == i), aes(x = fiplot, \n                                                     ymin = low, \n                                                     ymax = high), alpha = 0.25, fill=\"blue\")+\n    coord_cartesian(ylim = c(-3, 4)) + \n    labs(title = paste(DS$Names[which(DS$ID==i)]),\n         x = NULL,\n         y = NULL) +\n    theme(text = element_text(size = 9), axis.text = element_text(size = 9),\n          legend.position = \"none\", strip.text = element_text(size = 6)) \n}\nfigure1 <- ggarrange(plotlist = plots[l_nazwy], nrow=3,ncol = 4)\nannotate_figure(figure1,\n                bottom = text_grob(expression(varphi)),\n                left = text_grob(\"log k\", rot = 90))\n```\n\n::: {.cell-output-display}\n![](initial_model_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nPopulation predictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplots <- list()\nfor(i in 1:nAnalytes){\n  l <- apply(drop(fit_sample$logkPlotAPred[,i,]), MARGIN = 2, FUN = quantile, probs = c(.025,.5,.975))\n  logk_prct <- as.data.frame(cbind(rep(i,11),fiplot,t(l)))\n  colnames(logk_prct)<-c(\"ID\",\"concentration\",\"low\",\"median\",\"high\")\n  plots[[i]] <- ggplot()+ xlim(0,1) +\n    geom_point(data=subset(DS, ID == i), aes(x = concentration, y = logk), col=\"blue\") +\n    geom_line(data=subset(logk_prct, ID == i), aes(x = fiplot, y = median), col=\"red\") +\n    geom_ribbon(data=subset(logk_prct, ID == i), aes(x = fiplot, \n                                                     ymin = low, \n                                                     ymax = high), alpha = 0.25, fill=\"red\")+\n    coord_cartesian(ylim = c(-3, 4)) + \n    labs(title = paste(DS$Names[which(DS$ID==i)]),\n         x = NULL,\n         y = NULL) +\n    theme(text = element_text(size = 9), axis.text = element_text(size = 9),\n          legend.position = \"none\", strip.text = element_text(size = 6)) \n}\nfigure1 <- ggarrange(plotlist = plots[l_nazwy], nrow=3,ncol = 4)\nannotate_figure(figure1,\n                bottom = text_grob(expression(varphi)),\n                left = text_grob(\"log k\", rot = 90))\n```\n\n::: {.cell-output-display}\n![](initial_model_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "initial_model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}