{
  "hash": "f6b59fcfe435ddefb6e26fae42b4d01c",
  "result": {
    "markdown": "# Model 2\n\nAs confirmed by model 1, the grouping of analytes is related to the degree of dissociation of compounds. Hence, model 2 takes into account the $pK_a$ information of the substances contained in the sample by determining the dissociated and neutral fractions.\n\nFor a monoprotic acid, the logarithm of the ratio of the ionized form to the neutral one at a particular pH = 2.66 is given by: \\begin{align*}\n\\log\\left(\\frac{fr'_{i}}{1-fr'_{i}}\\right) = pH-pK_{a,i}\n\\end{align*}\n\nwhere $fr'_{i}$ denotes the ratio of ionized to total concentration of a compound ($\\frac{[A^-]}{[A^-]+[HA]}$) as predicted using $pK_a$ from ACD/Labs software. Since $pK_a$ and pH are measured with an error, it is convenient to introduce an error term at the scale of (pH and $pK_a$) and convert back to the adjusted fraction denoted $fr_{i}$: \\begin{gather*}\n    fr_{i}=\\frac{1}{1+10^{-{\\left(\\log\\left(\\frac{fr'_i}{1-fr'_i}\\right)+\\eta_i\\right)}}},  \\\\\n\\eta_i \\sim t\\textnormal{-Student}(7,0,0.1) \n\\end{gather*}\n\nwhere $\\eta_i$ is a random variable corresponding to the error described by Student's $t$-distribution with a mean of 0, standard deviation of 0.1, and 7 degrees of freedom. A very small scale was used to indicate that the most likely $pK_a$ values are close to the true values (accurately predicted by ACD/Labs program). Nevertheless, the presence of some outlying values was handled by Student's $t$-distribution. The reasoning presented here for the monoprotic analytes was extended to polyprotic analytes as shown in the Supporting Information.\n\nThis model estimates the parameters $\\log k_w$, $\\log k_a$, and $\\log S_2$ as the following sum, taking into account the analyte-specific $fr_{i}$ values: \\begin{align*}\n\\begin{bsmallmatrix}\n\\log{k_{w,i}}  \\\\\n\\log{k_{a,i}} \\\\\n\\log{S_{2,i}}\n\\end{bsmallmatrix}=& \\,fr_{i} \\cdot   \\text{MST}\\left(7,   \\begin{bsmallmatrix}\n &\\theta_{\\log{k_{w_1}}} +\\beta_{\\log k_{w_{1}}} \\cdot \\log{P_i}, & \\\\\n & \\theta_{\\log{k_{a_1}}} +\\beta_{\\log k_{a_{1}}} \\cdot \\log{P_i}, &  \\\\\n& \\theta_{\\log{S_{2_1}}} +\\beta_{\\log S_{2_{1}}} \\cdot \\log{P_i}, &\n\\end{bsmallmatrix}, \\Omega_1\\right) + \\\\\n+& \\, (1-fr_{i}) \\cdot \\text{MST}\\left(7, \\begin{bsmallmatrix}\n &\\theta_{\\log{k_{w_2}}} +\\beta_{\\log k_{w_{2}}} \\cdot \\log{P_i}, & \\\\\n&\\theta_{\\log{k_{a_2}}} +\\beta_{\\log k_{a_{2}}} \\cdot \\log{P_i}, & \\\\\n& \\theta_{\\log{S_{2_2}}} +\\beta_{\\log S_{2_{2}}} \\cdot \\log{P_i}, &\n\\end{bsmallmatrix},  \\Omega_2 \\right).\n\\end{align*} It should be noted that this is a simplification. Theoretically, the retention factor should be expressed by: \\begin{align*}\n    k_{i} =fr_{i} \\cdot k_{ionized} +(1-fr_{i}) \\cdot k_{neutral} .\n\\end{align*} Nevertheless, for this particular data, the formulas are practically equivalent, since almost all compounds exist either as neutral or as dissociated form. Only 14% of analytes are expected to be partially dissociated (\\$\\<\\$90% of the neutral or dissociated form present in a solution). Clearly, to fully elucidate the effects of pH on retention, more extensive data are needed, e.g., those collected for a wide range of pH values of the mobile phase.\n\n## Priors\n\nIn this model, the same priors as in the model 1 were adopted.\n\n\n```{=tex}\n\\begin{align*}\n\\theta_{\\log k_{w_1}} \\sim N(1.054, 1.136),  \\quad \\theta_{\\log k_{w_2}} \\sim N(2.053, 1.487),\\\\\n\\theta_{\\log k_{a_1}} \\sim N(-3.437, 1.062), \\quad \\theta_{\\log k_{a_2}} \\sim N(-1.885, 1.006),\\\\\n\\theta_{\\log S_{2_1}},  \\sim N(\\log 2,0.2), \\quad \\theta_{\\log S_{2_2}},  \\sim N(\\log 2,0.2), \\\\\n\\beta_{\\log k_{w_1}} \\sim N(0.7,0.25), \\quad \\beta_{\\log k_{w_2}} \\sim N(0.7,0.25),\\\\\n\\beta_{\\log k_{a_1}} \\sim N(0.3,0.25), \\quad \\beta_{\\log k_{a_2}} \\sim N(0.3,0.25), \\\\\n\\beta_{\\log S_{2_1}} \\sim N(0,0.25), \\quad \\beta_{\\log S_{2_2}} \\sim N(0,0.25), \\\\\n\\text{logPmissing} \\sim N(2.56,1.92), \\\\\n\\omega_{\\log k_{w_1}}\\sim \\textnormal{N}_{+}(0,1.136),  \\, \\omega_{\\log k_{a_1}}\\sim \\textnormal{N}_{+}(0,1.487), \\, \\omega_{\\log S_{2_1}}\\sim \\textnormal{N}_{+}(0,0.2), \\\\ \\omega_{\\log k_{w_2}}\\sim \\textnormal{N}_{+}(0,1.062), \\, \\omega_{\\log k_{a_2}}\\sim \\textnormal{N}_{+}(0,1.006), \\, \\omega_{\\log S_{2_2}} \\sim \\textnormal{N}_{+}(0,0.2), \\\\\n\\begin{bmatrix}\n 1 & \\rho_{1,2_1} & \\rho_{1,3_1} \\\\\n \\rho_{2,1_1} & 1 & \\rho_{2,3_1} \\\\\n \\rho_{3,1_1} & \\rho_{3,2_1} & 1 \n \\end{bmatrix}, \\begin{bmatrix}\n1 & \\rho_{1,2_2} & \\rho_{1,3_2} \\\\\n \\rho_{2,1_2} & 1 & \\rho_{2,3_2} \\\\\n \\rho_{3,1_2} & \\rho_{3,2_2} & 1 \n \\end{bmatrix} \\sim LKJ(1), \\\\\n\\sigma \\sim \\textnormal{N}_{+}(0,0.067).\n\\end{align*}\n```\n\nDue to the implementation of the model in the program, the state was assumed and using the built-in inv_logit function ( $\\text{inv_logit}(u)=\\frac{1}{1+e^{-u}}$), it was assumed that:\n\n\n```{=tex}\n\\begin{align*}\n\\eta \\sim \\textnormal{Student t}(7,0,0.23).\n\\end{align*}\n```\n\n## Analysis\n\nModel was constructed and implemented in the Stan program.\n\n\n::: {.cell output.var='initial_model'}\n\n```{.stan .cell-code}\nfunctions{\n  real hplcmodel(real fi, real logkw, real logka, real logS2A){\n    \n    real logk;\t\t\t\t\t// retention factor\n    real S1;\t\t\t\t\t\t// slope coefficient\n    \n    S1 = (logkw - logka)*(1+10^logS2A);\n    logk = logkw - S1 * fi / (1 + 10^logS2A * fi);\n    \n    return logk;\n  }\n}\n\ndata{\n  int nAnalytes;\t\t\t  // number of analytes\n  int nObs;\t\t\t\t    \t// number of observations\n  int analyte[nObs];\t\t// analytes indexes\n  vector[nObs] logkObs;\t// observed retention factors\n  vector[nObs] fi;\t\t\t// organic modifier content in the mobile phase\n  real logP[nAnalytes];         // molecular descriptor      \n  int idxmissing[nAnalytes];    // indexes of logP missing value\n  real<lower=0, upper=1> rawlambdai[nAnalytes];  // ratio of ionized to total concentration of a compound\n  \n  int nfiplot;\t\t\t\t\t\t\t\t  // number of fi for plotting\n  vector[nfiplot] fiplot;\t\t\t\t// organic modifier content in the mobile phase\n  \n  int<lower = 0, upper = 1> run_estimation; // 0 for prior predictive, 1 for estimation\n}\n\n\ntransformed data {\n  real oddsi[nAnalytes];\n \nfor(j in 1:nAnalytes){\n  oddsi[j] = logit(rawlambdai[j]);\n}\n}\n\nparameters{\n  ordered[2] logkwHat;\t\t\t\t\t// mean value of logkw in population\n  ordered[2] logkaHat;          // mean value of logka in population\n  vector[2] logS2AHat;\t\t\t\t\t// mean curvature coefficient for acetonitrile in population\n\n  real<lower = 0> sigma;\t\t\t\t\t// standard deviation for residuals\n  vector<lower = 0>[3] omega1;\t\t// diagonal elements of variance-covariance matrix \n  corr_matrix[3] rho1;\t\t\t\t\t  // correlation matrix\n  vector<lower = 0>[3] omega2;\t  // diagonal elements of variance-covariance matrix \n  corr_matrix[3] rho2;\t\t\t\t\t\t// correlation matrix\n  real beta[6];\t\t\t\t\t\t\t\t\t  // coefficient value for molecular descriptor\n  real logPmissing[nAnalytes];    // logP Missing values\n  vector[3] param1[nAnalytes];\n  vector[3] param2[nAnalytes];\n  real eta[nAnalytes];\n}\n\ntransformed parameters{\n \n  vector[3] miu1[nAnalytes];\t \n  vector[3] miu2[nAnalytes];\t \n  real logka[nAnalytes];     // mean value of logka in population\n  real logkw[nAnalytes];     // mean value of logkw in population\n  real logS2A[nAnalytes];    // mean curvature coefficient for acetonitrile in population\n  cov_matrix[3] Omega1;\t\t\t // variance-covariance matrix\n  cov_matrix[3] Omega2;\t\t\t // variance-covariance matrix\n  vector[nObs] logkHat;\t\t\t // mean value of logk in population\n  real<lower=0, upper=1> frac[nAnalytes];\n\n  Omega1 = quad_form_diag(rho1, omega1);\t// diag_matrix(omega) * rho * diag_matrix(omega)\n  Omega2 = quad_form_diag(rho2, omega2);\t// diag_matrix(omega) * rho * diag_matrix(omega)\n\n  for(j in 1:nAnalytes){\n    miu1[j,1]  = logkwHat[1]  +  beta[1] * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]);\n    miu2[j,1]  = logkwHat[2]  +  beta[2] * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]);\n    miu1[j,2]  = logkaHat[1]  +  beta[3] * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]); \n    miu2[j,2]  = logkaHat[2]  +  beta[4] * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]); \n    miu1[j,3]  = logS2AHat[1] +  beta[5] * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]);\n    miu2[j,3]  = logS2AHat[2] +  beta[6] * ((1-idxmissing[j])*logP[j]+idxmissing[j]*logPmissing[j]);\n    frac[j]  = inv_logit(oddsi[j] + eta[j]);\n  }\n\n\tfor(j in 1:nAnalytes){\n\tlogkw[j]  = param1[j, 1]*frac[j] + param2[j, 1]*(1-frac[j]);\n\tlogka[j]  = param1[j, 2]*frac[j] + param2[j, 2]*(1-frac[j]);\n\tlogS2A[j] = param1[j, 3]*frac[j] + param2[j, 3]*(1-frac[j]);\n\t}\n  \n\n  for(i in 1:nObs){\n    logkHat[i] = hplcmodel(fi[i], logkw[analyte[i]], logka[analyte[i]], logS2A[analyte[i]]);\n }\n  \n}\nmodel{\n  \n  logkwHat[1]  ~ normal(1.054, 1.136);\n  logkwHat[2]  ~ normal(2.053, 1.487);\n  logkaHat[1]  ~ normal(-3.437, 1.062);\n  logkaHat[2]  ~ normal(-1.885, 1.006);\n  logS2AHat[1] ~ normal(log10(2), 0.2);\n  logS2AHat[2] ~ normal(log10(2), 0.2);\n\n  beta[1] ~ normal(0.7,0.25);\n  beta[2] ~ normal(0.7,0.25);\n  beta[3] ~ normal(0.3,0.25);\n  beta[4] ~ normal(0.3,0.25);\n  beta[5] ~ normal(0,0.25);\n  beta[6] ~ normal(0,0.25);\n\n  logPmissing ~ normal(2.56,1.92); // based on logP fit\n\n  eta ~ student_t(7,0,0.23);\n\n  omega1[1] ~ normal(0,1.136);\n  omega1[2] ~ normal(0,1.487);\n  omega1[3] ~ normal(0,0.2);\n  rho1   ~ lkj_corr(1);\n  omega2[1] ~ normal(0,1.062);\n  omega2[2] ~ normal(0,1.006);\n  omega2[3] ~ normal(0,0.2);\n  rho2\t ~ lkj_corr(1);\n  sigma\t ~ normal(0,0.067);\n\n  for(i in  1:nAnalytes){\n  param1[i] ~ multi_student_t(7, miu1[i],Omega1);\n  param2[i] ~ multi_student_t(7, miu2[i],Omega2);\n  }\n  \n  if(run_estimation==1){\n  logkObs ~ student_t(7,logkHat, sigma);\t// observations\n  }\n}\n\ngenerated quantities{\n\n  real logkCond[nObs];\n  real log_lik[nObs];\n  real log_likPred[nObs];\n  real logkHatPred[nObs];\n  real logkaPred[nAnalytes];\n  real logkwPred[nAnalytes];\n  real logS2APred[nAnalytes];\n  real<lower=0, upper=1> fracPred[nAnalytes];\n  \n  matrix[nAnalytes,nfiplot] logkHatPlotACond;\n  matrix[nAnalytes,nfiplot] logkPlotACond;\n\n  vector[3] paramPred1[nAnalytes];\t \n  vector[3] paramPred2[nAnalytes];\n  \n  for(j in 1:nAnalytes){\n\n  real etaPred[nAnalytes];\n\n  etaPred[j] = student_t_rng(7,0, 0.23);\n  fracPred[j]  = inv_logit(oddsi[j] + etaPred[j]);\n  \n  paramPred1[j] =  multi_student_t_rng(7,miu1[j],Omega1);\n  paramPred2[j] =  multi_student_t_rng(7,miu2[j],Omega2);\n\n  logkwPred[j]  = paramPred1[j, 1]*fracPred[j] + paramPred2[j, 1]*(1-fracPred[j]);\n  logkaPred[j]  = paramPred1[j, 2]*fracPred[j] + paramPred2[j, 2]*(1-fracPred[j]);\n  logS2APred[j] = paramPred1[j, 3]*fracPred[j] + paramPred2[j, 3]*(1-fracPred[j]);\n  }\n  \n  for(i in 1:nObs){\n    logkCond[i] = student_t_rng(7,logkHat[i], sigma);\n    log_lik[i]\t= student_t_lpdf(logkObs[i] | 7,logkHat[i], sigma);\n    logkHatPred[i]\t= hplcmodel(fi[i], logkwPred[analyte[i]], logkaPred[analyte[i]], logS2APred[analyte[i]]);\n    log_likPred[i] = student_t_lpdf(logkObs[i] | 7,logkHatPred[i], sigma); \n\n  }\n}\n```\n:::\n\n\nThen, the data was added to it and the initial values of the model parameters were determined. In the end, the model was fitted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages\nlibrary(pracma)\nlibrary(dplyr)\nlibrary(ggplot2)\nrequire(gridExtra)\nlibrary(GGally)\nlibrary(cmdstanr)\nlibrary(rstan)\nlibrary(knitr)\nlibrary(reshape2)\nlibrary(bayesplot)\nlibrary(posterior)\n\n# load data\nDS       <- read.csv(here::here(\"1_data/database_stan_1026.csv\"),header = TRUE, sep = \";\", dec = \".\")\nDS_names <- read.csv(here::here(\"1_data/database_stan_1026_analyte_names.csv\"),header = TRUE, sep = \",\", dec = \".\")\nDS_pKa   <- read.csv(here::here(\"1_data/ACD_pKas.csv\"),header = TRUE, sep = \",\", dec = \".\")\n\nnAnalytes=length(unique(DS$ID))\n\n# calculating fractions of analytes in pH=2.658\npH <- 2.658\npKas <- DS_pKa[,3:5]\nfr <- matrix(rep(0,nAnalytes*4),nAnalytes,4)\ncharge <- DS_pKa[,9:12] + DS_pKa[,13:16]\ncharge_pH <- rep(0,nAnalytes)\nlambda <- rep(0,1026)\nfor(i in 1:nAnalytes){\n  cums<-cumsum(c(pKas[i,]))\n  x<-c()\n  x[1]<-1\n  for(j in 1:3){\n    x[j+1]<- 10^(j*pH-cums[j])\n  }\n  fr[i, ] <- as.matrix(x/sum(x))\n  charge_pH[i] <- charge[i,which.max(fr[i,])]\n  lambda[i] <- sum(fr[i,which(charge[i,]==0)])\n}\n\n# calculation of logk versus fi curves\ninitial_param <- matrix(NA,nAnalytes,3)\nfor(i in 1:nAnalytes){\n  if(length(DS$concentration[which(DS$ID==i)])==1){\n    initial_param[i,2] <- polyfit(-16*DS$concentration[which(DS$ID==i)]/(1+2*DS$concentration[which(DS$ID==i)]),\n                                  DS$logk[which(DS$ID==i)],0)\n    initial_param[i,1] <- -16\n  }else{\n    initial_param[i,1:2] = \n      polyfit(DS$concentration[which(DS$ID==i)]/(1+2*DS$concentration[which(DS$ID==i)]),\n              DS$logk[which(DS$ID==i)],1)\n  }\n}\ninitial_param[,3] <- rep(2,nAnalytes)\n\nID        <- unique(DS$ID)\nlogP_ACD  <- DS$logP_ACD[!duplicated(DS$ID)]\nlogkw     <- initial_param[,2]\nlogka     <- initial_param[,2] + initial_param[,1]/3\nlogS2     <- log10(initial_param[,3])\n\nParameters_basic_fit  <-  data.frame(ID,logP_ACD,logkw,logka,logS2)\nrm(ID,logkw,logka,logS2,initial_param)\n\n# indicating missing value of log P\nidxmissing <- rep(0,1026)\nidxmiss <- which(is.nan(DS$logP_ACD[!duplicated(DS$ID)]))\nidxmissing[idxmiss] <- 1\n\nDS$logP_ACD[which(DS$ID %in% idxmiss)] <- 0\n\nlambda[which(lambda>0.999)]=0.999\nlambda[which(lambda<0.001)]=0.001\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlogP=DS$logP_ACD[!duplicated(DS$ID)]\nnObs=length(DS$ID)\nanalyte=DS$ID\nlogkObs=DS$logk\nfi=DS$concentration\nfiplot=seq(0,1,0.1)\nnfiplot=length(fiplot)\nrun_estimation=1\n\n# data to model\ndatastruct_prior = with(DS,\n                    list(logP=DS$logP_ACD[!duplicated(DS$ID)],\n                       idxmissing=idxmissing,\n                       nAnalytes=nAnalytes,\n                       nObs=nObs,\n                       analyte=DS$ID,\n                       logkObs=DS$logk, \n                       fi=DS$concentration,\n                       rawlambdai=1-lambda,\n                       nfiplot=length(fi),\n                       fiplot=fi,\n                       run_estimation=0))\n\ndatastruct = with(DS,\n                  list(logP=DS$logP_ACD[!duplicated(DS$ID)],\n                       idxmissing=idxmissing,\n                       nAnalytes=nAnalytes,\n                       nObs=nObs,\n                       analyte=DS$ID,\n                       logkObs=DS$logk, \n                       fi=DS$concentration,\n                       rawlambdai=1-lambda,\n                       nfiplot=length(fi),\n                       fiplot=fi,\n                       run_estimation=1))\n\n# declaring initial values for each variable in chains\ninit <- function(){\n  list(logkwHat  = sort(c(rnorm(1,2,0.2),rnorm(1,2,0.2)+max(0,rnorm(1,2,0.5)))),\n       logkaHat  = sort(c(rnorm(1,-4,0.2),rnorm(1,-4,0.2)+max(0,rnorm(1,2,0.5)))),\n       logS2AHat = rnorm(2,log(2),0.2),\n       \n       omega1= c(1,1,0.1)*exp(rnorm(3,0,0.2)),\n       rho1 = diag(1,3,3),\n       omega2= c(1,1,0.1)*exp(rnorm(3,0,0.2)),\n       rho2 = diag(1,3,3),\n       \n       beta = c(0.7,0.7,0.5,0.5,0,0)*exp(rnorm(6,0,0.2)),\n       \n       param1 = Parameters_basic_fit[,3:5]*0.9,\n       param2 = Parameters_basic_fit[,3:5]*1.1,\n       sigma  = rlnorm(1,log(0.1),0.2)\n  )\n}\n\n# specifying parameters to analysis \nparametersToPlot <- c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"omega1\",\"rho1\",\"omega2\",\"rho2\",\"beta\",\n                      \"param1\",\"param2\",\"sigma\",\"logPmissing\")\notherRVs <- c(\"logkCond\",\"logkPlotACond\",\"fracPred\",\"log_lik\",\"logkwPred\",\"logkaPred\",\"logS2APred\",\n              \"logkHat\",\"paramPred1\",\"paramPred2\",\"logkw\",\"logka\",\"logS2A\",\"logkHatPred\",\"log_likPred\")\n\nparameters <- c(parametersToPlot, otherRVs)\nparametersToPlot <- c(\"lp__\", parametersToPlot)\n\n# fitting model\nfit_prior <- stan(file=\"ACN002.stan\",\n            data=datastruct_prior,\n            pars=parameters,\n            iter=2000,\n            warmup=1000,\n            init=init,\n            chains=4,thin=1,control = list(adapt_delta = 0.9,max_treedepth=15))\n\nfit <- stan(file=\"ACN002.stan\",\n                   data=datastruct,\n                   pars=parameters,\n                   iter=2000,\n                   warmup=1000,\n                   init=init,\n                   chains=4,thin=1,control = list(max_treedepth=12))\n```\n:::\n\n\nBelow code preapering data to fit the model in supercomputer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogP=DS$logP_ACD[!duplicated(DS$ID)]\nnAnalytes=length(unique(DS$ID))\nnObs=length(DS$ID)\nanalyte=DS$ID\nlogkObs=DS$logk\nfi=DS$concentration\nfiplot=seq(0,1,0.1)\nnfiplot=length(fiplot)\nrun_estimation=1\n\nstan_rdump(c(\"logP\",\n             \"nAnalytes\", \n             \"nObs\",\n             \"idxmissing\", \n             \"analyte\", \n             \"logkObs\", \n             \"fi\",\n             \"rawlambdai\",\n             \"nfiplot\",\n             \"fiplot\",\n             \"run_estimation\"),\n           file=\"4_model_2/model.data.R\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in stan_rdump(c(\"logP\", \"nAnalytes\", \"nObs\", \"idxmissing\", \"analyte\", :\nobjects not found: rawlambdai\n```\n:::\n\n```{.r .cell-code}\nfor(i in 1:10){\n  logkwHat  = sort(c(rnorm(1,2,0.2),rnorm(1,2,0.2)+max(0,rnorm(1,2,0.5))))\n  logkaHat  = sort(c(rnorm(1,-4,0.2),rnorm(1,-4,0.2)+max(0,rnorm(1,2,0.5))))\n  logS2AHat = rnorm(2,log(2),0.2)\n  omega1= c(1,1,0.1)*exp(rnorm(3,0,0.2))\n  rho1 = diag(1,3,3)\n  omega2= c(1,1,0.1)*exp(rnorm(3,0,0.2))\n  rho2 = diag(1,3,3)\n  beta = c(0.7,0.7,0.5,0.5,0,0)*exp(rnorm(6,0,0.2))\n  param1 = Parameters_basic_fit[,3:5]*0.9\n  param2 = Parameters_basic_fit[,3:5]*1.1\n  sigma  = rlnorm(1,log(0.1),0.2)\n  \n  stan_rdump(c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"beta\",\"rho1\",\"rho2\",\"omega1\",\"omega2\",\"param1\",\"param2\",\"sigma\"),\n             file=paste(\"4_model_2/model_\", i, \".init.R\", sep=\"\"))\n}\n```\n:::\n\n\n## Summary of model parameters\n\nCode for print summary of parameters from supercomputer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- cmdstanr::as_cmdstan_fit(c('4_model_2/output_1.csv',\n                                  '4_model_2/output_2.csv',\n                                  '4_model_2/output_3.csv',\n                                  '4_model_2/output_4.csv',\n                                  '4_model_2/output_5.csv',\n                                  '4_model_2/output_6.csv',\n                                  '4_model_2/output_7.csv',\n                                  '4_model_2/output_8.csv',\n                                  '4_model_2/output_9.csv',\n                                  '4_model_2/output_10.csv'))\n\nfit$print(c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"beta\",\"rho1\",\"rho2\",\"omega1\",\"omega2\",\"param1\",\"param2\",\"sigma\"), max_rows = 26)\n```\n:::\n\n\nCode for print summary of parameters from computer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(\"4_model_2/Fit.Rsave\")\nload(\"4_model_2/Fit_sample.Rsave\")\n\nprint(fit,pars=c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"beta\",\"rho1\",\"rho2\",\"omega1\",\"omega2\",\"sigma\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInference for Stan model: ACN0021_10_09.\n4 chains, each with iter=2000; warmup=1000; thin=1; \npost-warmup draws per chain=1000, total post-warmup draws=4000.\n\n              mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat\nlogkwHat[1]   1.13       0 0.14  0.86  1.03  1.13  1.21  1.40   962 1.00\nlogkwHat[2]   2.57       0 0.12  2.33  2.49  2.57  2.65  2.81  1971 1.00\nlogkaHat[1]  -2.95       0 0.11 -3.18 -3.02 -2.95 -2.87 -2.73   616 1.00\nlogkaHat[2]  -1.21       0 0.03 -1.27 -1.23 -1.21 -1.19 -1.15  2136 1.00\nlogS2AHat[1]  0.46       0 0.03  0.41  0.44  0.46  0.48  0.51   590 1.00\nlogS2AHat[2]  0.61       0 0.02  0.58  0.60  0.61  0.62  0.64  1534 1.00\nbeta[1]       0.87       0 0.05  0.78  0.83  0.87  0.90  0.96   783 1.01\nbeta[2]       0.85       0 0.04  0.76  0.82  0.85  0.87  0.93  1102 1.00\nbeta[3]       0.25       0 0.03  0.18  0.23  0.25  0.27  0.32   610 1.00\nbeta[4]       0.20       0 0.01  0.18  0.20  0.20  0.21  0.22  2352 1.00\nbeta[5]      -0.01       0 0.01 -0.03 -0.02 -0.01 -0.01  0.00   615 1.00\nbeta[6]      -0.05       0 0.01 -0.06 -0.05 -0.05 -0.04 -0.04  1031 1.00\nrho1[1,1]     1.00     NaN 0.00  1.00  1.00  1.00  1.00  1.00   NaN  NaN\nrho1[1,2]     0.44       0 0.05  0.34  0.41  0.44  0.48  0.54   432 1.03\nrho1[1,3]     0.43       0 0.05  0.33  0.39  0.43  0.46  0.52   594 1.01\nrho1[2,1]     0.44       0 0.05  0.34  0.41  0.44  0.48  0.54   432 1.03\nrho1[2,2]     1.00       0 0.00  1.00  1.00  1.00  1.00  1.00  3366 1.00\nrho1[2,3]     0.62       0 0.04  0.53  0.59  0.62  0.64  0.69   519 1.02\nrho1[3,1]     0.43       0 0.05  0.33  0.39  0.43  0.46  0.52   594 1.01\nrho1[3,2]     0.62       0 0.04  0.53  0.59  0.62  0.64  0.69   519 1.02\nrho1[3,3]     1.00       0 0.00  1.00  1.00  1.00  1.00  1.00   159 1.00\nrho2[1,1]     1.00     NaN 0.00  1.00  1.00  1.00  1.00  1.00   NaN  NaN\nrho2[1,2]     0.32       0 0.05  0.23  0.29  0.32  0.35  0.41  1313 1.00\nrho2[1,3]     0.39       0 0.05  0.29  0.35  0.39  0.42  0.48   786 1.00\nrho2[2,1]     0.32       0 0.05  0.23  0.29  0.32  0.35  0.41  1313 1.00\nrho2[2,2]     1.00       0 0.00  1.00  1.00  1.00  1.00  1.00  3333 1.00\nrho2[2,3]    -0.21       0 0.05 -0.31 -0.24 -0.21 -0.17 -0.10   844 1.01\nrho2[3,1]     0.39       0 0.05  0.29  0.35  0.39  0.42  0.48   786 1.00\nrho2[3,2]    -0.21       0 0.05 -0.31 -0.24 -0.21 -0.17 -0.10   844 1.01\nrho2[3,3]     1.00       0 0.00  1.00  1.00  1.00  1.00  1.00  2528 1.00\nomega1[1]     1.31       0 0.07  1.17  1.26  1.30  1.35  1.46   490 1.00\nomega1[2]     1.01       0 0.05  0.92  0.98  1.01  1.04  1.11   475 1.01\nomega1[3]     0.23       0 0.01  0.20  0.22  0.23  0.24  0.25   479 1.01\nomega2[1]     1.50       0 0.07  1.37  1.45  1.50  1.54  1.64   676 1.00\nomega2[2]     0.36       0 0.02  0.32  0.34  0.36  0.37  0.39   678 1.01\nomega2[3]     0.18       0 0.01  0.17  0.18  0.18  0.19  0.20   838 1.00\nsigma         0.03       0 0.00  0.03  0.03  0.03  0.03  0.03   745 1.01\n\nSamples were drawn using NUTS(diag_e) at Mon Nov 09 13:55:42 2020.\nFor each parameter, n_eff is a crude measure of effective sample size,\nand Rhat is the potential scale reduction factor on split chains (at \nconvergence, Rhat=1).\n```\n:::\n:::\n\n\n## Goodness of fit\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(metRology) # function rt.scaled\n\nlogkPred <-array(rep(5097*4000),dim=c(4000,5097))\nfor(j in 1:nObs){\n  for(k in 1:4000){\n    logkPred[k,j]\t\t= rt.scaled(1,7,fit_sample$logkHatPred[k,j], fit_sample$sigma[k])\n  }\n}\n\npar(mfrow=c(1,2))\nplot(apply(fit_sample$logkCond,2,mean),DS$logk,cex.lab=1.2,xlim=c(-4,6),ylim=c(-3,3),pch=20,col=\"blue\",ylab=expression(\"Log k\"[Obs]),xlab=expression(\"Log k\"[Pred]))\nlines(seq(-4,6,by=0.1),seq(-4,6,by=0.1),lwd=2)\nplot(apply(logkPred,2,mean),DS$logk,cex.lab=1.2,xlim=c(-4,6),ylim=c(-3,3),pch=20,col=\"blue\",ylab=expression(\"Log k\"[Obs]),xlab=expression(\"Log k\"[Pred]))\nlines(seq(-4,6,by=0.1),seq(-4,6,by=0.1),lwd=2)\n```\n\n::: {.cell-output-display}\n![](model_2_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n### WAIC\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(loo)\nwaic(extract_log_lik(fit)) # to samo co: waic(fit_sample$log_lik)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: \n2211 (43.4%) p_waic estimates greater than 0.4. We recommend trying loo instead.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nComputed from 4000 by 5097 log-likelihood matrix\n\n          Estimate    SE\nelpd_waic   7660.0 219.5\np_waic      3635.8 203.4\nwaic      -15320.1 438.9\n\n2211 (43.4%) p_waic estimates greater than 0.4. We recommend trying loo instead. \n```\n:::\n\n```{.r .cell-code}\nloo(extract_log_lik(fit))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Relative effective sample sizes ('r_eff' argument) not specified.\nFor models fit with MCMC, the reported PSIS effective sample sizes and \nMCSE estimates will be over-optimistic.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some Pareto k diagnostic values are too high. See help('pareto-k-diagnostic') for details.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nComputed from 4000 by 5097 log-likelihood matrix\n\n         Estimate    SE\nelpd_loo   7325.4 122.8\np_loo      3970.5  95.5\nlooic    -14650.8 245.7\n------\nMonte Carlo SE of elpd_loo is NA.\n\nPareto k diagnostic values:\n                         Count Pct.    Min. n_eff\n(-Inf, 0.5]   (good)     2863  56.2%   77        \n (0.5, 0.7]   (ok)        987  19.4%   50        \n   (0.7, 1]   (bad)       917  18.0%   12        \n   (1, Inf)   (very bad)  330   6.5%   2         \nSee help('pareto-k-diagnostic') for details.\n```\n:::\n:::\n\n\n## Predictions\n\nIndividual predictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggpubr)\n\nnazwy <- c(\"Caffeine\",\"Chlorpropamide\",\"Doxepin hydrochloride\",\"Perphenazine\",\n  \"Pindolol\",\"Phenylbutazone\",\"Procainamide hydrochloride\",\"Retinoic acid\",\n  \"Sulfaphenazole\",\"Tolbutamide\",\"Ketoprofen\",\"Indomethacin\")\nl_nazwy <- which(DS_names$Analyte[!duplicated(DS_names$ID)] %in% nazwy)\n\nplots <- list()\nfor(i in 1:nAnalytes){\n  l <- apply(drop(fit_sample$logkPlotACond[,i,]), MARGIN = 2, FUN = quantile, probs = c(.025,.5,.975))\n  logk_prct <- as.data.frame(cbind(rep(i,11),fiplot,t(l)))\n  colnames(logk_prct)<-c(\"ID\",\"concentration\",\"low\",\"median\",\"high\")\n  plots[[i]] <- ggplot()+ xlim(0,1) +\n    geom_point(data=subset(DS, ID == i), aes(x = concentration, y = logk), col=\"blue\") +\n    geom_line(data=subset(logk_prct, ID == i), aes(x = fiplot, y = median), col=\"blue\") +\n    geom_ribbon(data=subset(logk_prct, ID == i), aes(x = fiplot, \n                                                     ymin = low, \n                                                     ymax = high), alpha = 0.25, fill=\"blue\")+\n    coord_cartesian(ylim = c(-3, 4)) + \n    labs(title = paste(DS$Names[which(DS$ID==i)]),\n         x = NULL,\n         y = NULL) +\n    theme(text = element_text(size = 9), axis.text = element_text(size = 9),\n          legend.position = \"none\", strip.text = element_text(size = 6)) \n}\nfigure1 <- ggarrange(plotlist = plots[l_nazwy], nrow=3,ncol = 4)\nannotate_figure(figure1,\n                bottom = text_grob(expression(varphi)),\n                left = text_grob(\"log k\", rot = 90))\n```\n\n::: {.cell-output-display}\n![](model_2_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nPopulation predictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhplc <- function(fi,logkw,logka,logS2A){\n  S1 = (logkw - logka)*(1+10^logS2A)\n  logk = logkw - S1 * fi / (1 + 10^logS2A * fi)\n  return(logk)\n}\n\nlogkHatPlotAPred <-array(rep(0,11*1026*8000),dim=c(8000,1026,11))\nlogkPlotAPred <-array(rep(0,11*1026*8000),dim=c(8000,1026,11))\n\nfor(j in 1:nAnalytes){\n  for(z in 1:nfiplot){\n    for(k in 1:8000){\n      logkHatPlotAPred[k,j,z]\t= hplc(fiplot[z], fit_sample$logkwPred[k,j],\n                                   fit_sample$logkaPred[k,j], fit_sample$logS2APred[k,j])\n      logkPlotAPred[k,j,z]\t\t= rt.scaled(1,7,logkHatPlotAPred[k,j,z], fit_sample$sigma[k])\n    }\n  }\n}\n\nplots <- list()\nfor(i in 1:nAnalytes){\n  l <- apply(drop(logkPlotAPred[,i,]), MARGIN = 2, FUN = quantile, probs = c(.025,.5,.975))\n  logk_prct <- as.data.frame(cbind(rep(i,11),fiplot,t(l)))\n  colnames(logk_prct)<-c(\"ID\",\"concentration\",\"low\",\"median\",\"high\")\n  plots[[i]] <- ggplot()+ xlim(0,1) +\n    geom_point(data=subset(DS, ID == i), aes(x = concentration, y = logk), col=\"blue\") +\n    geom_line(data=subset(logk_prct, ID == i), aes(x = fiplot, y = median), col=\"red\") +\n    geom_ribbon(data=subset(logk_prct, ID == i), aes(x = fiplot, \n                                                     ymin = low, \n                                                     ymax = high), alpha = 0.25, fill=\"red\")+\n    coord_cartesian(ylim = c(-3, 4)) + \n    labs(title = paste(DS$Names[which(DS$ID==i)]),\n         x = NULL,\n         y = NULL) +\n    theme(text = element_text(size = 9), axis.text = element_text(size = 9),\n          legend.position = \"none\", strip.text = element_text(size = 6)) \n}\nfigure1 <- ggarrange(plotlist = plots[l_nazwy], nrow=3,ncol = 4)\nannotate_figure(figure1,\n                bottom = text_grob(expression(varphi)),\n                left = text_grob(\"log k\", rot = 90))\n```\n\n::: {.cell-output-display}\n![](model_2_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n### Uncertainty chromatograms\\n\\nPlot uncertainity chromatograms expected isocratically at fi=0.5 for 7 randomly selected analytes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reshape2)\nanalyte_ID_sample <- c(122,370,412,626,650,719,772)\ndata_to_plot <- logkPlotAPred[,which(DS_names$ID %in% analyte_ID_sample),which(fiplot==0.5)]\ncolnames(data_to_plot) <- paste(DS_names$Analyte[analyte_ID_sample])\n\nwp <- melt(data_to_plot)\np <- ggplot(aes(x=value, colour=Var2), data=wp)\np + geom_density() + xlim(c(-3,3)) + xlab(\"Logarithm retention factor\") + guides(colour=guide_legend(title=\"Compouds\"))\n```\n\n::: {.cell-output-display}\n![](model_2_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nPlot uncertainity chromatograms expected for a typical gradient for 7 randomly selected analytes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhplcmodelgra <- function(logkw,logka,logS2A,tg,fio,fif,to,td,te,time){\n  fi = fio - (fio-fif)/tg*(time-td)\n  fi[which(time<td)] = fio\n  fi[which(time>tg+td)] = fif\n  S1 = (logkw - logka)*(1+10^logS2A)\n  tr <- matrix(NA,nrow(logkw),ncol(logkw))\n  for(i in 1:nrow(logkw)){\n    for(j in 1:ncol(logkw)){\n      logki = logkw[i,j] - S1[i,j]*fi/(1 + 10^logS2A[i,j]*fi)\n      ki = 10^logki\n      inv_k_i = 1/to/ki\n      cumtr  = cumtrapz(time,inv_k_i)\n      if(cumtr[length(cumtr)]>=1){\n        trprim = interp1(as.vector(cumtr),time,1)\n      }else{\n          trprim = (1-cumtr[length(cumtr)])*ki[length(ki)]*to+time[length(time)]\n      }\n      tr[i,j] = trprim + to + te\n    }\n  }\n  return(tr)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_to_plot <- hplcmodelgra(fit_sample$logkwPred[,analyte_ID_sample],\n                             fit_sample$logkaPred[,analyte_ID_sample],\n                             fit_sample$logS2APred[,analyte_ID_sample],\n                             20,0,1,1,0.2,0,seq(0,20+10,length.out=1000))\ncolnames(data_to_plot) <- paste(DS_names$Analyte[analyte_ID_sample])\n\nwp <- melt(data_to_plot)\np <- ggplot(aes(x=value, colour=Var2), data=wp)\np + geom_density() + xlim(c(0,30)) + xlab(\"Retention time\") +\n  guides(colour=guide_legend(title=\"Compouds\"))\n```\n\n::: {.cell-output-display}\n![](model_2_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nanalyte_ID_sample <- c(112, 122, 241, 379,498, 512, 626, 672, 726, 772)\ndata_to_plot <- hplcmodelgra(fit_sample$logkwPred[,analyte_ID_sample],\n                             fit_sample$logkaPred[,analyte_ID_sample],\n                             fit_sample$logS2APred[,analyte_ID_sample],\n                             20,0,1,1,0.2,0,seq(0,20+10,length.out=1000))\ncolnames(data_to_plot) <- paste(DS_names$Analyte[analyte_ID_sample])\n\nwp <- melt(data_to_plot)\np <- ggplot(aes(x=value, colour=Var2), data=wp)\np + geom_density() + xlim(c(0,30)) + xlab(\"Retention time\") + guides(colour=guide_legend(title=\"Compouds\"))\n```\n\n::: {.cell-output-display}\n![](model_2_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "model_2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}